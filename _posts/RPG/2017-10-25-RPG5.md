---
layout: post
title: 从零制作一款RPG游戏 第一章 第EX节 位操作节省内存的原理
category: RPG
tags: Java, Game, RPG
keywords: Java, Game, RPG
description: 从零制作一款RPG游戏 第一章 第EX节
---

第EX节是什么鬼啦。

好久没更新了，今儿来做一次更新，这一节讲述位操作节省空间的原理，正常做游戏因为只需要实现，原理并不重要，所以可能用不到这一节的内容，只给想要深究的人和做游戏参加比赛的人。

## 分析代码普遍性
为了方便研究，我把之前位操作的代码搬来：
```java
return (this.mapBlock[index >>> 6] & 1L << (index & 63) - 1) != 0L;
```
我们只需要在意这一部分：
```java
mapBlock[index >>> 6] & 1L << (index & 63) - 1
```
这是储存代码，为了方便研究我把`i`还成了`index`，把`mapLongs`换成了`mapBlock`，把`mapBlock`换成了`bBlock`：
```java
if(bBlock[index]) {
    mapBlock[index >>> 6] |= 1L << (index & 63) - 1;
} else {
    mapBlock[index >>> 6] &= ~(1L << (index & 63) - 1);
}
```

我们发现，尽管get和set的方法不同，但有两部分是一模一样的，那就是`mapBlock[index >>> 6]`和`1L << (index & 63) - 1`，所以我们从这两部分开始分析。

### `mapBlock[index >>> 6]`
这个代码用途太简单了，就是获取`index`对应格子所在的`long`，我们关键来看`index >>> 6`。

因为Java中，长整型的长度为64字节(64 = 2＾6)，所以当我们用`index`查找对应的`long`时我们只需要看`index`是64的多少倍就可以了，如果`index`除以64的结果是2余15那对应格子当然在第3个`long`里面，如果`index`小于64自然就在第一个`long`里。

另外，`>>> 6`等效于`/ 64`所以`index >>> 6`就是index对应的格子所在的`long`。

你可能会问，如果`index`除以64得2余15应该在第三个`long`里，而这里除完却没有加1是不是不对？这里要注意，第一个`long`是`mapBlock[0]`，第二个是`mapBlock[1]`,第x个是`mapBlock[x-1]`，如果我们加了1，自然又要减1，这一加一减刚好抵消，所以我的代码没错。

### `1L << (index & 63) - 1`
看到`& 63`就先把63化成二进制，这里我告诉你63的二进制是0b00111111，想必你已经知道`index & 63`的作用了。对，`index & 63`就是留下index的后六位其他全部扔掉，我们刚刚利用除了后六位以外的部分找到了对应的`long`，这后六位就是用来定位我们找到的`long`中对应的那一位了。

运算操作先于位操作，所以接下来就要给转换后的`index`减1，也许机会问为什么要减1，别忘了，如果我们要找第x位，那那一位的位置就在x-1。

然后将1左移我们的`index`，效果就是得到一个二的n次方数，这个数的二进制中是1的那一位刚好和long中我们要找的那一位是同一位，假设我们要找第五位，此时效果就是这样的：

|          位数          | 8 | 7 | 6 | 5 | 4 | 3 | 2 | 1 |
|:------------------------|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|
| `mapBlock[index >>> 6]`  | 1 | 0 | 1 | 1 | 0 | 0 | 0 | 1 |
| `1L << (index & 63) - 1` | 0 | 0 | 0 | 1 | 0 | 0 | 0 | 0 |

## 各项操作
### get
如果我们查询第五位，效果就是这样的：

|          位数          | 8 | 7 | 6 | 5 | 4 | 3 | 2 | 1 |
|:------------------------|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|
| `mapBlock[index >>> 6]`  | 1 | 0 | 1 | 1 | 0 | 0 | 0 | 1 |
| `1L << (index & 63) - 1` | 0 | 0 | 0 | 1 | 0 | 0 | 0 | 0 |
| `&` | 0 | 0 | 0 | 1 | 0 | 0 | 0 | 0 |

但如果是第四位：

|          位数          | 8 | 7 | 6 | 5 | 4 | 3 | 2 | 1 |
|:------------------------|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|
| `mapBlock[index >>> 6]`  | 1 | 0 | 1 | 1 | 0 | 0 | 0 | 1 |
| `1L << (index & 63) - 1` | 0 | 0 | 0 | 0 | 1 | 0 | 0 | 0 |
| `&` | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 |

因此，两种结果相互&，结果为零就说明对应一位为0，否则为1。

### set
将第四位变成1，效果是这样的：

|          位数          | 8 | 7 | 6 | 5 | 4 | 3 | 2 | 1 |
|:------------------------|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|
| `mapBlock[index >>> 6]`  | 1 | 0 | 1 | 1 | 0 | 0 | 0 | 1 |
| `1L << (index & 63) - 1` | 0 | 0 | 0 | 0 | 1 | 0 | 0 | 0 |
| `^` | 1 | 0 | 1 | 1 | 1 | 0 | 0 | 1 |

>Fuck制表符和或是同一个字符我只好用^代替了，好气啊。ヽ(`Д´)ﾉ

将第五位变成0，效果是这样的：

|          位数          | 8 | 7 | 6 | 5 | 4 | 3 | 2 | 1 |
|:------------------------|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|
| `mapBlock[index >>> 6]`  | 1 | 0 | 1 | 1 | 0 | 0 | 0 | 1 |
| `~(1L << (index & 63) - 1)` | 1 | 1 | 1 | 0 | 1 | 1 | 1 | 1 |
| `&` | 1 | 0 | 1 | 0 | 0 | 0 | 0 | 1 |

小朋友们，你们学会了吗？

我猜你们很多人没看懂，罢了，好在这一节不重要。